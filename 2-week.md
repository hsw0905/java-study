### 2주차 학습할것

### 프리미티브 타입의 종류와 값의 범위 그리고 기본 값

- primitive type (원시 타입 혹은 기본형 타입)
- 타입? (데이터 타입, 자료형)
- 데이터가 메모리에 어떻게 저장될 것이고, 어떻게 다뤄질 것인가
- 데이터 타입 -> 컴퓨터에서 어떤 형태를 가지며, 어떻게 처리될 수 있는지

#### Java의 기본 내장된 타입 정리

- 논리형 : boolean (1byte)
- 정수형 : byte(1byte), short(2byte), int(4byte), long(8byte)
- 실수형 : float(4byte), double(8byte)
- 문자형 : char(2byte) (유니코드)
- 1byte = 8bit -> 8bit로 표현 가능한 값의 개수 = 2의 8제곱
- 컴퓨터에서의 음수 표현 (MSB: Most Significant Bit (최상위비트))
- MSB : 부호 비트로 사용 (1이면 음수, 0이면 양수)
- 따라서, 1byte 표현 가능 범위 -> -128 ~ 127

- 실수형 : 값을 부호, 지수, 가수로 나누어 저장된다
- 같은 크기임에도 훨씬 큰 범위 표현 가능하지만, 원래 의도하던 값과 오차가 있을 수 있다.
- 오차 없는 자리수인 정밀도가 중요
- 정밀도를 계산하려면? 가수 부분의 데이터 크기와 관련이 있다
- 예)float의 가수부분은 23비트인데, 2^24는 10^7보다 크고, 10^8보단 작기에 float의 정밀도는 7자리가 된다 (double형은 15자리)
- 돈 계산 등의 정밀한 부분을 코딩할 때는 float 이나 double 대신에 BigDecimal을 사용해야 한다

```java
float num = 0f;
for (int i = 0; i < 10; i++)
{
	num += 0.1f;
}
System.out.println(num); // 1.0000001 (not 1.0)
```

```java
BigDecimal num = BigDecimal.ZERO;
for (int i = 0; i < 10; i++)
{
  num = num.add(BigDecimal.valueOf(0.1));
}
System.out.println(num);  // 1.0
```

- int형도 범위가 큰 정수형일 경우 BigInteger를 사용

### 프리미티브 타입과 레퍼런스 타입

- 레퍼런스 타입 : 실제 값이 저장되어 있는 메모리 주소값을 저장
- 기본적으로 java.lang.Object를 상속받을 경우 참조형이 된다
- 배열, 열거(enum), class, interface 등등
- 저장되는 값이 실제 값 자체인가 vs 메모리 주소값인가에 따라 프리미티브타입 vs 레퍼런스 타입 구분
- 프리미티브 타입 : 스택 영역 저장
- 레퍼런스 타입 : 힙 영역 저장
- 예)new 키워드로 클래스를 인스턴스화 시키면, 인스턴스화된 변수는 heap 영역의 객체 주소가 저장된다

### 리터럴

- 실제로 저장되는 값 그 자체
- 메모리에 저장되어 있는 변하지 않는 값 그 자체
- 또는 컴파일 타임에 프로그램 안에 정의되어 그 자체로 해석되어야 하는 값
- 쉽게 말해 코드에서 직접 쓴 값
- 본래 이런 값들은 상수라 불러야 하지만 프로그래밍에서는 상수를 '값을 한번 저장하면 변경할 수 없는 저장공간으로 정의했기 때문에 이와 구분하기 위해 리터럴 이라는 용어를 사용한다
- 그러므로 리터럴은 기존에 알고 있던 상수의 다른 이름이라고 볼 수 있다
- 인스턴스 안의 값이 불변성을 보장한다면 객체 리터럴이 될 수 있다
- 예) java.lang.String, java.awt.Color (내용이 변하면 새로운 객체를 만들어 내용의 불변성이 보장됨)
- 종류 : 정수, 실수, 문자, 부울(논리), 문자열 등
- 문자열을 제외하고 프리미티브 타입으로 표현 가능
- 정수 리터럴은 기본적으로 int형이고 long 타입을 표현하려면 l 혹은 L을 마지막에 붙여야 함
- 실수 리터럴은 기본적으로 double형이고, float 타입을 표현하려면 f를 마지막에 붙여야 함
- 문자 리터럴 : 'a' (문자열은 "abc") <따옴표 차이>

### 변수 선언 및 초기화하는 방법

- 변수를 선언하면, 메모리의 빈 공간에 변수타입에 맞는 크기의 저장공간이 확보되고, 변수 이름을 통해 해당 저장공간을 사용할 수 있게 된다
- 대입 연산자 = 를 통해 초기화 가능
- <초기화 시기와 순서(라이프타임)>
- 클래스 변수 : 기본값 -> 명시적 초기화 -> 클래스 초기화 블록
- 인스턴스 변수 : 기본값 -> 명시적 초기화 -> 인스턴스 초기화 블록 -> 생성자

### 변수의 스코프와 라이프타임

- 스코프 : 변수가 존재할 수 있는 영역, 접근 범위
- 변수의 위치에 따라 클래스 변수, 인스턴스 변수, 지역 변수로 나누어짐
- 인스턴스 변수 : 클래스의 인스턴스를 생성할 때 만들어짐
- 클래스 변수 : 맴버변수에 static 붙이면 클래스 변수
- (한 클래스의 모든 인스턴스가 값을 공유한다)
- 클래스 변수, 인스턴스 변수 : (공통) 클래스 영역에서 선언
- 클래스 변수의 스코프 : 클래스 전역(클래스 기반으로 생성된 각각의 인스턴스에 공유됨)
- 인스턴스 변수의 스코프 : 각 인스턴스
- 지역변수의 스코프 : 메소드, 생성자, 초기화 블록 내부

### 타입 변환, 캐스팅 그리고 타입 프로모션

```java
int b = 10;
long a = int(b);
```

- 타입 변환은 손실이 일어날 수 있음
- 하위 클래스로 캐스팅은 가능, 같거나 상위 레벨인 클래스로 캐스팅은 불가

```java
int a = 10;
long b = a; // 묵시적으로 자동 캐스팅 (프로모션)
```

### 1차 및 2차 배열 선언하기

```java
// 1차원 배열
int[] array_1 = {1, 2, 3, 4, 5};
int[] array_2 = new int[10];

// 2차원 배열
int[][] array_3 = {{1, 2}, {3, 4}};
int[][] array_4 = new int[10][10];

```

### 타입 추론, var

- 타입추론이란 정적 타이핑을 지원하는 언어에서, 타입이 정해지지 않은 변수에 대해 컴파일러가 변수의 타입을 스스로 찾아낼 수 있도록 하는 기능
- 즉, 타입을 명시하지 않아도 되며, 코드량을 줄이고 가독성을 높일 수 있다
- Java 10부터 var구문이 생기고 Java 11 부터는 이를 통한 람다 타입 지원도 생겼다. 컴파일러는 개발자가 입력한 초기화 값을 통해 타입을 유추하게 되는데, var는 컴파일러가 타입을 유추할 수 있도록 반드시 데이터를 초기화 해야 한다.

```java
// 자바 9
String message = "hello";

// 자바 10
var message = "hello";
```

```java
// 자바 9
for(Harry harry: harryList){
	...
}
// 자바 10
for(var harry : harryList) {
	...
}

```

- 위 경우 var 키워드를 Harry 클래스로 인식할 수 있게 되고, 컴파일시 var 키워드를 Class Harry로 변환하여 인식한다
